"serv": "ts-node-dev --respawn --pretty --transpile-only server.ts",

 // "server": "nodemon --exec ts-node server.ts",
 "server": "nodemon server.ts",


notes:

1. in GraphQL, all types are nullable by default!
2. to get object from mutation with saving: return a promise, resolve with the product!
3. urql - results.stale crucial for having up to date db data! 
[server.js & SingleBookmark -> favicon test on click]
[server.js & testMutation -> adding additional data through middleware and passing to graphql resolver test]


 issues:
 
 DONE 2. working graphql playground DONE
 DONE 3. adding user doesn't return anything on graphql playground? (but it returns in changeSettings) (see notes pt.2) DONE
 DONE 5. bookmarkSchema.ts: is <Array> type enough? [string] DONE 
 DONE 3. id: string | number or string only? unify with client (client: string only) DONE
 DONE 4. client: SingleTabData: [object] | never[] | [] ????
   <- not being used actually in the client? (items deleted from rss clientside) DONE
 DONE 8. client: ALL_TAGS should not be an id but rather deletable property should be used! ids will be added automatically be database DONE
 DONE 9. deleteUser -> promise.all should be used instead of individual promises? for performance DONE
 DONE 16. upserts in changeMutations -> should be false mostly? (all false )DONE
 DONE 18. client: comment out useStorage (zustand's perist commented out) DONE
 DONE 34. mutations -> proper typescript types! DONE
DONE 45. logic for tab deletion in Grid work only thanks to setTimeout() [in Boomark_lowerUI] -> make it better!!! DONE (result.stale used!!!)
DONE 46. bookmark /tabs database interfaces everywhere! (now both from context) DONE
DONE 47. promise.all -> no need for new Promise everywhere? mutation return promises (change in Bookmark_lowerUI, no promise.all in Grids now, ) DONE
DONE 49. rss -> still not working because of CORS, fetch them server side? DONE
 
 1. livereload npm
 
 6. userSchema gets ref to settingsSchema, should it be also the other war around?
 
10. typescript doesn't work for schemas?

11. deleteTabMutation -> should it also delete related Bookmark automatically?
14. non-null types: same everywhere!
15. fields -> id can be an argument even if it is never used? delete it from fields?
16. make npm run dev open 2 console instances
17. bookmarkAllTags should be filled from db at the start

18. Column: better error handling?
19. bookmarks: better query -> finding the bookmarks matched to a particular tab right away
21. unhandled promise rejections! addUser, handle it everywhere!
22. use zustand state conditionally if the user is not authenticated

23. delete testUserId in the end
24. client: rss settings merges with global settings -> test -> delete all commented out code
25. typescript: save eg. settingsType new Settings -> save() method does not exist
26. all settings working with db init
27. globalSettings make it impossible to enter a value other than 5-15!
28. client: make + & - for rss itemsPerPage  
29. Main -> fetching and date are after useEffects (globalSettings in a useEffect dep) but globalSettings is declared already?
30. globalSettings taken either from props or from hooks (hooks cannot apply if useEffect uses globalSettings
+ it requires more code) -> unify? -> currently hook is in MainWrapper & Column
31. interfaces: database vs client side: currently settings are from database but tabs from clientside...
32. clientside: hooks for store -> sometimes it's state.tabs, sometimes store.tabs -> unify
33. take care of state other that settings, tabs & bookmarks (use of existings queries should be enough?)
35. client-side: unify column_1 naming with server-side naming (colColor_1 itp) when the client-side code
 will be working again for nonauthorised user!
36. addBookmark -> tabQueries should be refetched?
37. way to use urql as a central state?
38. editBookmark doesn't work on the client!
39. objCreators: too much repetition in db tab creators?
40. bookmarksAllTags -> change it (it should be a list of all tabs ids that are bookmarks tags) or use mongoose query!!!!
41. newTab -> no color as argument, should be null
42. editing Tab -> bookmarks are not sorted alphabetically!
43. Tab (and other components further down?) should take tab data from Column (context??), not from db?
44. clientside: tab are set to default individually -> should be handle more centrally? (in Grid, as it is done server-side now),
45. memory leaks? when adding bookmark
46. bookmarks not up to date when adding newBookmark if there are none -> hacky solution only, reexectuing query which causes rerender - solve?
47. useBookmarks & useTabs -> mark which methods are used server-side!
48. explain somewhere to the user why disable drag & drop is there
50. server.ts -> figure out which cors urls are actually needed
51. fix any types (server.js multer?)
52. change app.use to app.get / app.post?
53. change server file upload logic to graphql?
54. move backgroundImg logic from server.js?
55. test which cors rules are actually needed
56. clientside: make it possible to choose backgroundImg colors also from settings? or close the modal and open backgroundColors menu
57. is path module needed? (server.js
58. status 201
59. graphql for file upload? use middleware which should detect if the file is attached to post req
60. flickering when uploadin background img file
61. background img -> currently there is no point in storing it in db, as it is get from server only??
62. upload background img -> should use one btn only??
63. cannot upload image if there are spaces in the file name?
64. npm modules should be imported like: import multer = require("multer"). with const types are not working!!
change everywhere!!
65. add qpl`` ... package to graphql schema
66. background img - remove it once the user is deleted? implemented already -test it!
67. delete all test mutation code in the end
68. list all links to free svgs in notes
69. delete unused test_svgs, rename the chosen one
70. singleBookmarkData: change interface to BookmarkDatabase_i ?
71. msg to user when clicking custom img and there is none present
72. graphql ID vd string type, they may be mixed
73. user creation: check if user name or email already exists
74. implement token versioning: refreshToken
75. Main -> change context values obj, so it is taken from state directly
75. fetchFavicon in server.js -> delete?
76. AppWrapper, MainWrapper in different placec - chaos?
77. UpperRightMenu: loggedInState -> change for it to be compatible with authContext
78. middleware for token -> generated code for types is being used??
79. is case of failure, accessToken will be an empty string - to change? compare with loginMutation
80. get rid of all ts "any"s
81. logout mutation: is refreshing site -why?
82. uninstall react-tracked
83. mainWrapper - too many or not enough?
84. user exp not perfect when logging out? flickering
85. Profile & LoginRegister doubled components
86. change initial load to localhost3000/ !
87. auth error - no user or no password - shouln't be separate errors!
88. isAuth -> ts errors
89. deleting all data when a user is deleted! done already? check
90. delete account option?
91. some img should be created as a custom image in the moment new user is created?
92. currently -> not authenticated -> test user from db is used -> change it to client only demo
93. notes on queries/schema/mongo etc.
94. Main, BackgroundSettings_Upload -> backgroundImgKey -> code not used anymore -> delete?
95. unify rssFetch & backgroundFetch serverside -> errors etc.
96.server.js unify -> different reponses, sometimes they are objects - not needed
97. graphql queries - proper types? ! or not
98. delete data -> rssExample
99. server.ts -> make separate files
100. server.txs -> rootValue -> is it needed?
101. graphql-tag -> check library!
102. react keys -> they should by indices ! change to id
103. unify callback functions -> function declaration instead of () => { }everywherw?
104. multer.any() <- change to single("name") somehow
105. delete the other background image
106. make it possible to changle background img when not logged in, again
107. write notes for file upload system!
108. not possible to write even a console.log in backgroundImgMutation even while is working?
109. backgroundImgUpload funcion -> for !req.body is next() needed?
110. demo id or test id naming
111. rootValue -> not needed?? check multer express graphql tut. change backgroundImgMutaion
112. test user Id server.ts check import
113. getting background img automatically
114. fallback if no backgroundImg available? or test it if it is not broking the app at least
115. backgroundImgQuery -> no variable needed? check after implementing unlogged version
116. useCallback -> is it really needed for uploads? no callback used right now
117. backgroundSettings_Upload -> reexecute query works after introducint async function!
118. change background upload UI!
119. BackgroudnSettings_Upload typescript issues

{
  filename: 'nature-3082832_1920.jpg',
  mimetype: 'image/jpeg',
  encoding: '7bit',
  createReadStream: [Function: createReadStream]      
}



"urql": "^2.0.5"


firecamp upload mutation: 
variables should be like that:
{
  "image": ""
}

mutation ($image: Upload!) {
    backgroundImgMutation(image: $image)
  }

6239ceb924aee400c5bc84ce"

JWT logic: 

0. Login component -> login Mutation (see below -> res from the server contains the refresh token in a cookie and is setting it on client),
 access token & authenticatedUserId is taken from the server response is saved to central state

serverside: Login mutation (vars: name/email, password): 
1. searches db by name/email
2. check if password is valid
3. sends refresh token (first creates it) in a cookie? (from the server)
 - so client has a refresh token in a cookie set now!!
[refresh token is being send in a request only if hiting /refresh_token (point 6)]
4. creates accessToken, returns it so it can be stored in central state (point 0)

5. clientside (ApolloClient/urqlClient?):
 every request to the server is going to have access token (in the headers) taken from central state

6. clientside during every app reload:
 App.js is posting to /refresh_token route on the server,
  which verifies if client has a valid refresh token in a cookie,
  if yes -> 
    server creates new refresh token and sends it back
    server sends access token in a response from the server
    access token is stored clientside in memory (central state)

7. creating new access token if old expires -> Apollo middleware? what about urql??

8. mutation/queries are being protected by isAuth, which checks if accessTOken is valid

9. logOut -> setting empty string in a cookie instead of refresh token + setting access token to null clientside

...more, check


To so sum up, after login: 
1. Client has a cookie with refresh token (that is not being sent with every request, but only to /refresh_token endpoint),
access token is stored in client's memory (state manager)), and it is being sent in every request to the server (in headers)
(mutations/queries are being protected by isAuth on the server, which checks if there is proper accessToken set in the header)

2. app reload: post to /refresh_token route -> after validating if client has proper refresh token in a cookie, new refresh token & access token is being sent to client

3. creating new access token if old expires -> apollo middleware



urql auth:

login mutation: code from willAuthError won't run!
central state should be updated after jwt logic is handled??




export interface AuthContextObj_i {
  isAuthenticated: boolean;
  authenticatedUserId: null | string;
  accessToken: null | string;
  loginNotification: null | string;
  loginErrorMessage: null | string;
}

export interface AuthContextZustand_i extends AuthContextObj_i {
  logout: () => void;
  loginAttempt: (
    isAuthenticated: boolean,
    userId: string,
    token: string
  ) => void;
}

import create from "zustand";

import { AuthContextZustand_i } from "../../utils/interfaces";

export const useAuth = create<AuthContextZustand_i>((set) => ({
  isAuthenticated: false,
  authenticatedUserId: null,
  accessToken: null,
  loginNotification: null,
  loginErrorMessage: null,
  logout: () => set(state => ({
      ...state,
      isAuthenticated: false,
      authenticatedUserId: null,
      accessToken: null
  })),
  loginAttempt: (isAuthenticated, userId, token) => set(state => ({
      ...state,
      isAuthenticated: isAuthenticated,
      authenticatedUserId: userId,
      accessToken: token
  }))

//   setLoggedInState: (trueOrFalse) =>
//     set((state) => ({
//       ...state,
//       loggedInState: trueOrFalse,
//     })),



}));



    